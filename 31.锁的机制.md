# MyISAM表锁  
MySQL的表级锁有两种模式：**表共享锁**和**表独占写锁**。  
对于MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对于MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM
表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他现成的读，写操作都会等待，直到
锁被释放为止。  
**MyISAM存储引擎的写锁阻塞读例子:**  
当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读，写操作都会等待，直到锁被释放为止。  
**MyISAM存储引擎的读锁阻塞写例子:**  
session1使用LOCK TABLE命令给表film_text加了读锁，session1可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，session2可以查询表film_text中
的记录，但更新就会出现锁等待。但可以更新或读其他表。  
## 如何加表锁  
MyISAM在执行查询语句（SELECT）前，**会自动给涉及的所有表加读锁**,在执行更新操作（UPDATE, DELETE, INSERT等）前，**会自动给涉及的表加写锁**,这个过程并
不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显示加锁。  
给MyISAM表显示加锁，一般是为了在一定程度上模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders,其中记录有各订单的总金额total，同时
还有一个订单明细表，order_detail，其中记录有各订单每一产品的金额小计subtotal，假设我们需要检查这两个表的金额合计是否相符，可能就需要执行如下两条sql；
```
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
```
这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：
```
Lock tables orders read local, order_detail read local;
Select sum(total) from orders;
Select sum(subtotal) from order_detail;
Unlock tables;
```
**要特别说明以下两点内容**：  
1、上面的例子在LOCK TABLES时加了local选项， 其作用就是在满足MyISAM表并发插入条件情况下，允许其他用户在表尾并发插入记录，有关MyISAM表的并发插入问题，
在后面还会进一步介绍。   
2、在用LOCK TABLES给表显示加表锁时，必须同时取得所有涉及到表的锁，并且MySQL不支持锁升级。也就是说，在执行LOCK TABLE后，只能访问显示加锁的这些表，
不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。其实，在自动加锁的情况下也基本如此，MyISAM总是一次获得sql语句所
需要的全部锁。这也正式MyISAM表不会出现死锁的原因。  
当使用LOCK TABLES时， 不仅需要一次锁定用到的所有表，而且，同一个表在SQL语句中出现多少次，就要通过与SQL语句中相同的别名锁定多少次，否则也会出错！举例
如下。  
(1) 对actor表获得读锁：  
```
mysql> lock table actor read; 
Query OK, 0 rows affected (0.00 sec)
```
(2) 但是通过别名访问会提示错误：  
```
mysql> select a.first_name,a.last_name,b.first_name,b.last_name 
from actor a,actor b 
where a.first_name = b.first_name and a.first_name = 'Lisa' and a.last_name = 'Tom' 
and a.last_name <> b.last_name;

ERROR 1100 (HY000): Table ‘a’ was not locked with LOCK TABLES
```
(3) 需要对别名分别锁定：  
```
mysql> lock table actor as a read,actor as b read;
```
(4) 按照别名的查询可以正确执行：  
```
mysql> select a.first_name,a.last_name,b.first_name,b.last_name 
from actor a,actor b where a.first_name = b.first_name 
and a.first_name = 'Lisa' and a.last_name = 'Tom' 
and a.last_name <> b.last_name;
```
## 并发插入  
上文提到过
